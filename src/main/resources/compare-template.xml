<?xml version="1.0" encoding="UTF-8" ?>
<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
<?xml-stylesheet type="text/xml" href="#stylesheet"?>
<!DOCTYPE doc [
<!ATTLIST xsl:stylesheet id	ID	#REQUIRED>
<!ATTLIST xsl:stylesheet version	CDATA	#IMPLIED>
<!ATTLIST xsl:stylesheet xmlns:xsl	CDATA	#IMPLIED>
<!ATTLIST xsl:stylesheet xmlns	CDATA	#IMPLIED>
]>
<articles>
	<xsl:stylesheet id="stylesheet"
		version="18.0"
		xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
		xmlns="http://www.w3.org/1999/xhtml"
		>
		<!-- place any xsl:import elements here -->
		<xsl:template match="xsl:stylesheet" />
		<xsl:output method="html" indent="yes" version="5.0" encoding="UTF-8" doctype-public=""/>

		<!-- html skeleton -->
		<xsl:template match="/">
			<xsl:variable name="color1">#e68a2f</xsl:variable>
			<xsl:variable name="color2">#2f31e6</xsl:variable>
			
			<html xmlns:x="http://telecom-paristech.fr/namespace/">
				<head>
					<title>Jecca</title>
					<meta charset="UTF-8" />
					<style>
						.entityList { /*float: right;*/ background-color: lightgray; padding: 1em; margin: 1em; font-size: 12px; }
						.entityList .entity { font-weight: bold; }
						.linespacer { font-size: 5px; }
					
						.stack {display: inline-flex; flex-direction: column;}
						span { white-space:nowrap; }
						
						/* general style for chain numbers, see style with id "chains" further below */
						.chain {display:none; }
						.chain { color: darkseagreen; top: -1.5ex; }
						[data-index="1"] .subscript { ; top: -1.75ex; }
						[data-index="2"] .subscript { ; top: -1.75ex; }
						.highlight  { text-shadow: .5px 0px .0px, -.5px 0px .0px;} 
						
						/* combine elements according to split attribute */
						[data-split="true"] .combined { visibility: hidden; }
						[data-split="false"] .annotator { visibility: hidden; }
						[data-split="false"] .combined { visibility: visible; }
						[data-split="false"]:hover .combined { visibility: hidden;  }
						[data-split="false"]:hover .annotator { visibility: visible; }

						.highlight .combined { visibility: hidden; }
						.highlight .annotator { visibility: visible; }

						table.overlay { display: inline-block; vertical-align: top; /*line-height: 100%; */}
						.combined, .combined td { height: 0px; }
						.combined td .collapse {
							height: 0px;
							display: block;
						}

						table.overlay,table.overlay tr,table.overlay td {
							padding: 0px;
							border: 0px;
							margin: 0px;
							border-spacing: 0px;
						}

						table.overlay td:nth-child(1) { text-align: right; }
						table.overlay not(tr:nth-child(0)) td:nth-child(2) {
							text-align: center; 
						}
						table.overlay td:nth-child(4) { text-align: left; }
						table.overlay .annotator .textColumn {
							font-size: 12px;
						}
						.entity { font-style: italic; }
						
						.combined, [data-index] { color: grey; }
						.symbol, .symbols { display: none; }

						.left{
							display: block;
							float:left; 
							width:50%;
						}
						
						.noselect {
							-webkit-touch-callout: none;
							-webkit-user-select: none;
							-khtml-user-select: none;
							-moz-user-select: none;
							-ms-user-select: none;
							user-select: none;
						}
					</style>
					<!-- container for annotator visibility rules -->
					<style>
						styleid { content: 'annotatorVisibility'; }
						/*hide annotators by adding a rule like [data-index="1"] { display: none}, show them by removing that rule */
					</style>
					
					<style>
						styleid { content: 'coloring:annotators'; }
						[data-split="false"] .highlight .annotator:first-child { text-shadow: .5px 0px .0px, -.5px 0px .0px;}
						
					</style>
					<style>
						styleid { content: 'coloring:noAnno'; }
						[data-index].highlight  { display: none; }
						.combined  { color:DarkSlateBlue;}
						[data-split] .combined { visibility: visible; }
						.symbol, .symbols { display: none; }
					</style>
					<style>
						styleid { content: 'coloring:eval'; }
						/* styles for evaluation */
						[data-eval="correct"].highlight * { color: green; }
						[data-eval="toomuch"].highlight * { color: red; }
						[data-eval="missing"].highlight * { color: red; }
						[data-eval="wrong"].highlight * { color: red; }
					</style>
					<style>
						styleid { content: 'coloring:diff'; }
						[data-split="false"] .highlight.annotator { color: green; }
						[data-split="true"] .highlight.annotator { color: red; }
					</style>
					<style>
						styleid { content: 'coloring:chains'; }
						.highlight.rightchain.annotator { color: green; }
						.highlight.wrongchain.annotator { color: red; }
						.highlight.rightchain.wrongchain.annotator { color: black; }
						.highlight.selected { /*border: solid black 1px;*/ text-decoration: underline; }
					</style>
					<style>
						styleid { content: 'highlighting:enabled'; }
						[data-index] { color: gray; }
						.highlightMode { display: initial; }
						.defaultMode { display: none; }
						.rightchain { text-decoration: underline; }
					</style>
					<style>
						styleid { content: 'highlighting:disabled'; }
						.combined { text-shadow: .5px 0px .0px, -.5px 0px .0px; color: black; }
						.highlightMode { display: none; }
						.defaultMode { display: initial; }
					</style>
					<style>
						styleid { content: 'symbols'; }
						.symbols { display: initial; }
						.symbol { display: initial; position: relative; bottom: 1ex; font-size: small; }
						[data-split="true"] .grouped-symbols, table.overlay:hover .grouped-symbols { display: none; }
						/*[data-split="false"] .symbols { position: relative; }
						[data-split="false"] .symbols .single-symbol { position: absolute; left: 0px; }*/
					</style>
	
					<style>
						styleid { content: 'chains'; }
						.chain {display:inline; user-select: none;
						-moz-user-select: none; -khtml-user-select: none; }
					</style>
				
					<style>
						[data-eval=""] { color: black; }
						
						body { height: 100vh; padding: 0px; margin: 0px;}
						/* using HolyGrail from https://philipwalton.github.io/solved-by-flexbox/demos/holy-grail/ */
						.grail, .grail-body { display: flex; flex-direction: column; }
						.grail-content { flex: 1; }
						.grail-nav { order: 1; }
						@media ( min-width : 750px) {
							.grail-body { flex-direction: row; flex: 1; }
							.grail-content { flex: 1; }
							.grail-nav { /* 10em is the width of the columns */ flex: 0 0 10em; margin: 0 10px 0 10px ;}
						}
						#mentionTable{
							margin-right: 3px;
						}
						#content {
							/* margin-right: 10vw; */
							margin-left: 1vw; 
							border-style: none;
							height: 100%;
							max-height: 70vh;
							overflow: auto;
							flex: 1 1 auto;
						}
						@media( min-width : 568px) {
							#content { max-height: 100vh; }
						}
						#eval {
							/*margin-right: 10vw;
							height: 25%;
							overflow: auto;*/
						}
						#wrapper {
							display: flex;
							flex-flow: column;
							height: 100vh;
						}
						/*#wrapper {	
							left:0px;
							margin-right: 17vw;
							/*margin-right: 15vw;*/
							height: 100%;
							overflow: auto;
						}
						#wrapper2 {	
							margin-right: 5px;
							position: fixed;
							top:5.5vw;	
							right:0px;
							/*height:100vh;*/
							width: 17vw;
							}*/

						#annotators {
						/*	margin-right: 2px;
							position: fixed;
							top:5.5vw;
							left:3px;
							right:0px;
							/*height:100vh;*/
							width: 15vw;*/
						}
						#control {
							position: fixed;
							top:3.5vw;
							right:0px;
							height: 100%;
						} 

						/*style for menu navigator*/
						.titlebar {
							list-style-type: none;
							margin: 0;
							padding: 0.5em;
							overflow: hidden;
							background-color: #333;
							color: white;
							font-size: 1.5em;
							font-weight: bold;
						}

						li {
							float: left;
						}


						.show {display:block;}

						select.menu {
							width: 94%;
							padding: 3%;
							border:0px;
							outline:0px;
							font:inherit;
						}
						select.metric {
							border:0px;
							outline:0px;
							font:inherit;
						}

						table, th, td {
							border: 1px solid black;
							border-collapse: collapse;
							text-align: center;
						}
						th, td {
							padding: 5px;
						}
					</style>

					<script type="text/javascript">
						<![CDATA[
							// ADD CODE INSIDE NEXT IF BLOCK
							function isUndefined(v) {
								return typeof v === "undefined";
							}
							// execute only once, see mozilla-bug-380828
							if(!isUndefined(document.getElementsByName)) {

								/** Take Json output from XML and collapse it, i.e. make attributes and children elements accessible by r["name"] and r["name"][childindex] */
								function collapseXMLJson(o) {
									var r = {};
									if(!isUndefined(o["attr"])) {
										var keys = Object.keys(o["attr"]);
										for(var i=0; i<keys.length; i++) {
											r[keys[i]] = o["attr"][keys[i]];
										}
									}
									if(!isUndefined(o["children"])) {
										var cs = o["children"];
										for(var i=0; i<cs.length; i++) {
											var name = cs[i]["name"];
											if(isUndefined(r[name])) {
												r[name] = new Array();
											}
											r[name].push(collapseXMLJson(cs[i]));
										}
									}
									return r;
								}

								annotators = collapseXMLJson(]]><xsl:apply-templates select="articles/annotators" mode="js"/><![CDATA[)["annotator"];
								metrics = collapseXMLJson(]]><xsl:apply-templates select="articles/metrics" mode="js"/><![CDATA[)["annotator"];
							}
						]]>
					</script>
				</head>
				<body class="grail">
					<div class="grail-body">
					<div id="wrapper" class="grail-content">
						<div class="titlebar" style="position: relative">
							Jecca
						</div>
					
						<div id="content">
							<xsl:apply-templates /> 
						</div>
					</div>
					<div id="wrapper2" class="grail-nav" style="font-size: 80%;">
						<div>
							<h3 style="background-color: #333;color:white;"> Options </h3>
							<!--<select class='menu' id="optDoc" size="2" onchange="document.getElementById('content').onclick()"> 
								<option value="allArticles" selected="true">All articles</option> 
								<option value="onePerTime">One at a time</option> 
							</select>-->

							<select class='menu' id="optColor" size="2" onchange="updateMode()" style="display: none;"> 
								<option value="annotator">annotator</option> 
								<option value="eval" selected="true">evaluation</option> 
							</select>
							Show <select id="optCombine" size="1" onchange="updateMode()"> 
								<!-- <option value="eval">color conflicting</option>  -->
								<option value="entity" selected="true">conflicting</option> 
								<option value="none">all</option> 
							</select>
							annotations
							<br/>

							<label><input id="showSymbols" type="checkbox" name="symbols"  onchange="cssStyle['symbols'].disabled = !this.checked; updateMode();"/>Show symbols</label>
							<br/>
							<label><input id="showChains" type="checkbox" name="chains" onchange="cssStyle['chains'].disabled = !this.checked; updateMode();"/>Show span limits</label>
						</div>
						<div>
							<h3 style="background-color: #333;color:white;"> Annotators </h3>
						</div>
						<div id="annotators" xmlns="http://www.w3.org/1999/xhtml">
						</div>	
						<div style='border-style: none;' >	
							<div id="eval" >	
								<h3 style="background-color: #333;color:white;"> Evaluation </h3>
								<div  id="evalTableSelection"> 
									<div   id="selectDiv" >
		 
									</div>
									<div  id="tableDiv"  >
		    
									</div>
									
								</div>
								<!-- <div class="left" id="diagram">
		  							<svg id="mySVG" height="240" width="500" xmlns="http://www.w3.org/2000/svg" >
										<line class="default"  x1="100" y1="10" x2="100" y2="210" style="stroke:rgb(0,0,0);stroke-width:1" />
										<line  class="default"  x1="100" y1="210" x2="300" y2="210" style="stroke:rgb(0,0,0);stroke-width:1" />
										<text class="default" x="80" y="60" fill="black">P</text>
										<text  class="default"  x="290" y="230" fill="black">R</text>
									</svg>
								</div> -->
							</div>
						</div>
						<div style="font-size: 80%; margin-top: 2ex;">
							* colors:
							<span class="defaultMode"><br/>
								<span data-eval="correct"><span>correct</span></span><br/>
								<span data-eval="wrong"><span>wrong</span></span><br/>
								<!-- <span data-eval="missing">missing</span> -->
							</span>
							<span class="highlightMode"><br/>
								<span class="annotator highlight" data-eval="correct">correct</span><br/>
								<span class="annotator highlight" data-eval="wrong">wrong</span><br/>
								<!-- <span class="annotator highlight" data-eval="missing">missing</span>
								<span class="annotator highlight rightchain">in right chain</span><br/>
								<span class="annotator highlight wrongchain">in wrong chain</span><br/>
								<span class="annotator highlight rightchain wrongchain">in both chains</span> -->
							</span>

						</div>
					</div>
					</div>
					
					<script type="text/javascript">
						<![CDATA[
						// ADD CODE INSIDE NEXT IF BLOCK
						function isUndefined(v) {
							return typeof v === "undefined";
						}
						// execute only once, see mozilla-bug-380828
						if(!isUndefined(document.getElementsByName)) {
							var content = document.getElementById("content");
							
							/** adapted from http://stackoverflow.com/a/19662291/1562506
								usage example:
								var img  = initElement(svg,'circle',{
									cx:100, cy:150, r:22,
									fill:'black'});
							*/
							function initElement( dad, name, attrs, text ){
								var doc = dad.ownerDocument;
								var svg = dad.ownerSVGElement || dad;
								var ns = initElement.$NAMESPACES;
								var defaultNS = svg.namespaceURI;
								if (!ns){
									ns = initElement.$NAMESPACES = {};
									for (var a=svg.attributes,i=a.length;i--;) if (a[i].prefix=='xmlns') ns[a[i].localName] = a[i].value;
								}
								var p = name.split(':');
								var el = p[1] ? doc.createElementNS(ns[p[0]],p[1]) : doc.createElementNS(defaultNS,name);
								for (var a in attrs){
									p = a.split(':');
									if (p[1]) el.setAttributeNS(ns[p[0]],p[1],attrs[a]);
									else      el.setAttributeNS(null,a,attrs[a]);
								}
								if (text) {
									el.insertAdjacentHTML('beforeend', text);
								}
								return dad.appendChild(el);
							}


							function elementLabeling(label, forElementId, divId){
								var newlabel = document.createElement("label");
								newlabel.setAttribute("for",forElementId);
								newlabel.innerHTML = label;
								divId.appendChild(newlabel);
							}
							

							/*To dynamically create the annotator checkboxes*/
							for(var k=0;k<annotators.length;k++){
								var id = annotators[k]["id"];
								var name = "annotator "+id;
								var attributes = {
									type:'checkbox', id:"checkTag"+id, name:'annotator'+id, value:"annotator"+id,
									onchange:"updateMode();", checked:'checked'};
								if(k==0) {
									name = "gold standard";
									delete attributes['checked'];
								}
								initElement(document.getElementById('annotators'),'input',attributes);
								elementLabeling(name,"checkTag"+annotators[k]["id"],document.getElementById('annotators'));
								if(k<annotators.length-1){
									var br = document.createElement('br');
									document.getElementById('annotators').appendChild(br);
								}
							}
							
							/* When the user clicks on the button, 
							toggle between hiding and showing the dropdown content */
							function dropDown(menuId) {
								document.getElementById(menuId).classList.toggle("show");
							}

							// Close the dropdown menu if the user clicks outside of it
							window.onclick = function(event) {
							  if (!event.target.matches('.dropbtn')) {

								var dropdowns = document.getElementsByClassName("dropdown-content");
								var i;
								for (i = 0; i < dropdowns.length; i++) {
								  var openDropdown = dropdowns[i];
								  if (openDropdown.classList.contains('show')) {
									openDropdown.classList.remove('show');
								  }
								}
							  }
							 }

							if(!isUndefined(metrics)) {
								var metricNames = new Array();
								for(var i=0;i<metrics[0].metric.length;i++) {
									var name = metrics[0].metric[i].name;
									metricNames.push(name);
								}
								var selectElem = initElement(document.getElementById('selectDiv'),'select',{id:'metricsSel', class:'metric', onchange:'fillEvalTable(this.value);'});

								/*To dynamically create the metrics select*/
								for(var j=0;j<metricNames.length;j++){
									var name = metrics[0].metric[j].name;
									var option = initElement(selectElem,'option',{value: name});
									option.innerHTML=name;
								}
							}

							function fillEvalTable(metric){
								var table = document.getElementById("evalTable");
								var headerArray=["Annotator", "precision (%)", "recall (%)"];
								if(document.getElementById("evalTable")!=null){
 									table.innerHTML = "";
 									var header = table.createTHead();
									var row = header.insertRow(0);
									for(i=0;i<headerArray.length;i++){
										var cell = row.insertCell(i);
										cell.innerHTML = "<b>"+headerArray[i] +"</b>";
									}
								}
								
								if(document.getElementById("evalTable")==null){
									table=document.createElement("table");
									table.setAttribute("id", "evalTable");	
									document.getElementById("tableDiv").appendChild(table);
									var header = table.createTHead();
									var row = header.insertRow(0);
									for(i=0;i<headerArray.length;i++){
										var cell = row.insertCell(i);
										cell.innerHTML = "<b>"+headerArray[i] +"</b>";
									}
								}
								
								for (var i=0;i<metrics.length;i++) {
									var anno=annotators[i]["id"];
									var row= table.insertRow(-1);
									var annoCell = row.insertCell(0);
									annoCell.innerHTML = "Anno "+anno;
									var precisionCell=null;
									var recallCell=null;
									for(var j=0;j<metrics[i].metric.length;j++){
										var map=metrics[i].metric[j];
										if(map["name"]==metric){
											precisionCell= row.insertCell(1);
											precisionCell.innerHTML = parseFloat(map["precision"]*100).toFixed(2);
											recallCell = row.insertCell(2);
											recallCell.innerHTML = parseFloat(map["recall"]*100).toFixed(2);
										}
									}
								 	if(precisionCell== null && recallCell==null){
								 		table.deleteRow(table.getElementsByTagName("TR").length-1);
									}	
								}
							
								var p = highlightCell(1);
								var r = highlightCell(2);
							}

							function highlightCell(column){
								var  max, rowNo = null;
								var table = document.getElementById("evalTable");
								var a = table.getElementsByTagName("TR");
								for (var i=1; i<a.length; i++) {
									var td = a[i].childNodes[column];
									if(!isUndefined(td)) {
										var val = td.innerHTML;
										if (rowNo == null || val > max) {
											max = val;
											rowNo = i;
										}
									}
								}
								if(rowNo != null) {
									var td = a[rowNo].childNodes[column];
									td.style.backgroundColor = "yellow";
								}
							}
							if(!isUndefined(metricNames)) {
								fillEvalTable(metricNames[0]);
							}
							else {
								document.getElementById("eval").style.display = "none";
							}

							/* fetch named css styles and store them in a map */
							var cssStyle = new Array();
							var cssGroup = new Array();
							var cssLen = document.styleSheets.length;
							for(var i=0; i<cssLen; i++) {
								var sheet = document.styleSheets[i];
								id = sheet.cssRules[0].cssText;
								if(isUndefined(id)) continue;
								var found = id.match(/^styleid.*content:\s*["']([^"']*)["']/);
								if(!found || found.length != 2) continue;
								id = found[1];
								cssStyle[id] = sheet;
								var colonPos = id.indexOf(":");
								if(colonPos >= 0) {
									var groupName = id.substr(0, colonPos);
									if(isUndefined(cssGroup[groupName])) {
										cssGroup[groupName] = new Array();
									}
									cssGroup[groupName][id.substr(colonPos+1)] = sheet;
									sheet.disabled = true;
								}
							}
							// transform coloring to cssGroup highlight
							var keys = Object.keys(cssGroup["coloring"]);
							cssGroup["coloringHighlight"] = new Array();
							for(var i=0; i<keys.length; i++) {
								var name = keys[i];
								sheet = cssGroup["coloring"][name];
								cssGroup["coloringHighlight"][name] = sheet;
								sheetCopy = document.createElement("style");
								sheetCopy.type = 'text/css';
								cssCode = '';
								for(var j=0; j<sheet.cssRules.length; j++) {
									// generate new rule
									nr = sheet.cssRules[j].cssText;
									nr = nr.replace(".highlight", "");
									cssCode += nr;
								}
								sheetCopy.innerHTML = cssCode;
								document.getElementsByTagName('head')[0].appendChild(sheetCopy);
								cssGroup["coloring"][name] = sheetCopy;
							}

							cssStyle["symbols"].disabled = !document.getElementById("showSymbols").checked;
							cssStyle["chains"].disabled = !document.getElementById("showChains").checked;
							
							/* enable coloring with the given id and disable all the others */
							function selectStyle(styles, id) {
								var keys = Object.keys(styles);
								for(var i=0; i<keys.length; i++) {
									styles[keys[i]].disabled = keys[i] !== id;
								}
							}

							var markSpans = document.querySelectorAll("span.mark");
							function updateMode() {
								var coloringGroup;
								var highlightMode = content.querySelectorAll(".highlight").length > 0;
								var optColor = document.getElementById("optColor");
								if(highlightMode) {
									coloringGroup = "coloringHighlight";
									selectStyle(cssGroup["highlighting"], "enabled");
									selectStyle(cssGroup["coloring"], null);
									//selectStyle(cssGroup[coloringGroup], "chains");
									selectStyle(cssGroup[coloringGroup], optColor.options[optColor.selectedIndex].value);
								} else {
									coloringGroup = "coloring";
									selectStyle(cssGroup["highlighting"], "disabled");
									selectStyle(cssGroup["coloringHighlight"], null);
									selectStyle(cssGroup[coloringGroup], optColor.options[optColor.selectedIndex].value);
								}

								var sheet = cssStyle["annotatorVisibility"];
								while(sheet.cssRules.length>0) {
									sheet.deleteRule(0);
								}
								function isEnabled(index) {
									return document.getElementById('checkTag' + index).checked;
								}
								var enabledTaggers = new Array();
								for(var i=0; i<annotators.length; i++) {
									if(isEnabled(annotators[i]["id"])) {
										enabledTaggers.push(annotators[i]["id"]);
									}
								}
								if(enabledTaggers.length == 0) {
									selectStyle(cssGroup[coloringGroup], "noAnno");
								}
								else {
									for(var i=0; i<annotators.length; i++) {
										if(!isEnabled("" + i)) {
											sheet.insertRule("[data-index='" + i + "'] { display: none; }", 0);
										}
									}
									for(var i=0; i<markSpans.length; i++) {
										var rows = markSpans[i].getElementsByTagName("tr");
										var groupSymbol = rows[0].getElementsByTagName("td")[2];
										while(groupSymbol.firstChild) { groupSymbol.removeChild(groupSymbol.lastChild); }

										if(enabledTaggers.length == 1) {
											markSpans[i].setAttribute("data-split", "true");
										}
										else {
											var base = null;
											var eval = null;
											var annotatorSpans = markSpans[i].getElementsByClassName("annotator");
											// TODO: fix bug if wrongly tagged by second annotator
											
											var optCombine = document.getElementById("optCombine");
											var combineAttribute = "data-" + optCombine.options[optCombine.selectedIndex].value;
											var startJ = 1-optCombine.selectedIndex;
											
											/* used to check whether some values have the same value */
											function accumulate(lastVal, newVal, disagreementValue) {
												if( lastVal == disagreementValue || (lastVal == null ? newVal : lastVal) != newVal) {
													return disagreementValue;
												}
												else {
													return lastVal || newVal;
												}
											}
											if(combineAttribute == "data-none") {
												base = "split";
											}
											else {
												for(var j=startJ; j<annotators.length; j++) {
													if(isEnabled("" + j)) {
														// always split highlighted spans
														if(annotatorSpans[j].classList.contains("highlight")) {
															base = "split";
														}
														var val = annotatorSpans[j].getAttribute(combineAttribute) || "";
														base = accumulate(base, val, "split");
														if(j>0) {
															var val = annotatorSpans[j].getAttribute("data-eval") || "";
															eval = accumulate(eval, val, "split");
														}
													}
												}
											}
											markSpans[i].setAttribute("data-split", base == "split");
											if(eval != "split") {
												// create symbol
												var toolTipText, index, dest, eval;
												toolTipText = evalToSymbol(eval);
												
												// symbol after each annotator's mention
												groupSymbol = initElement(groupSymbol, 'span', {
													class:"grouped-symbols"});
												groupSymbol = initElement(groupSymbol, 'span', {
													class:"symbols"});
												initElement(groupSymbol,'span',{
													class:"symbol" 
													}, toolTipText);
											}
											
										}
									}
								}
							}
							updateMode();

							/* add a value to the values of a key (in a multi-map) */
							function put(map, key, value) {
								if(key != null) {
									list = map[key] || (map[key] = new Array());
									list.push(value);
								}
							}
							
							/* helper to insert nodes in DOM*/
							function after(newNode, refNode) {
								if(isUndefined(refNode) || isUndefined(newNode)) return false;
								refNode.parentNode.insertBefore(newNode, refNode.nextSibling);
							}
							function replace(newNode, refNode) {
								if(isUndefined(refNode) || isUndefined(newNode)) return false;
								return refNode.parentNode.replaceChild(newNode, refNode);
							}

							function ancestorWithClass(element, clazz) {
								var ancestor = element;
								while((ancestor = ancestor.parentElement) && !ancestor.classList.contains(clazz));
								return ancestor;
							}

							function removeClass(element, clazz) {
								selection = element.querySelectorAll("." + clazz)
								for(i=0; i<selection.length; i++) {
									selection[i].classList.remove(clazz);
								}
							}

							/* deselect highlight on click */
							content.onclick = function() {
								removeClass(content, "highlight");
								updateMode();
							}
							/* highlight chains on click on a mention */
							function markOnclick(e) {
								e.stopPropagation();
								// check whether user has selected this element
								var wasHighlighted = ancestorWithClass(e.target, "highlight") != null;
								// deselect
								removeClass(content, "selected");
								removeClass(content, "highlight");
								removeClass(content, "rightchain");
								removeClass(content, "wrongchain");
								if(wasHighlighted) {
									updateMode();
									return;
								}
								var ancestor = ancestorWithClass(e.target, "annotator");
								if(ancestor == null) return;
								ancestor.classList.add("selected");
								var index = ancestor.getAttribute("data-index");
								var thisEntity = ancestor.getAttribute("data-entity");
								var goldEntity = ancestorWithClass(e.target, "mark").getAttribute("data-entity0");
								// determine which elements to select
								var elements = [].concat(entityToElements[index][thisEntity]);
								elements = elements.concat(entityToElements[0][goldEntity]);
								// highlight selection
								for(i=0; i < elements.length; i++) {
									if(!isUndefined(elements[i])) {
										var annotatorSpans = [elements[i]];
										if(!elements[i].classList.contains("annotator")) {
											annotatorSpans = elements[i].querySelectorAll(".annotator[data-index='" + index + "']");
										}
										for(var j=0; j<annotatorSpans.length; j++) {
											var annotatorSpan = annotatorSpans[j];
											annotatorSpan.classList.add("highlight");
											if(ancestorWithClass(annotatorSpan, "mark").getAttribute("data-entity0") == goldEntity) {
												annotatorSpan.classList.add("rightchain");
											}

											if(annotatorSpan.getAttribute("data-entity") == thisEntity && ancestor.getAttribute("data-eval") != "correct") {
												annotatorSpan.classList.add("wrongchain");
											}
										}
									}
								}
								updateMode();
							}

							/* generate tooltip */
							function annotatorInfo(element, em0, emI) {
								var eval = element.getAttribute("data-eval")
								switch (eval) {
									case "correct":
										result = "correctly annotated with '" + emI + "'";
										if(isUndefined(emI)) console.log(new Error().stack);
										break;
									case "toomuch":
										result = "should not be annotated, found '" + emI + "'";
										break;
									case "missing":
										result = "should have been annotated with '" + em0 + "'";
										break;
									case "wrong":
										result = "should have been '" + em0 + "', but found '" + emI + "'";
										break;
									default:
										result = "not annotated";
								}
								return result;
							}

							function isEmpty(n) {
								return isUndefined(n) || n == null || n == "";
							}

							// map from entity to annotator to element
							var entityToElements = new Array();
							for(var i=0; i<annotators.length; i++) {
								entityToElements.push(new Array());
							}
							/* initialize annotator spans (onclick, associated entities, annotator info) */
							for(var i=0; i<markSpans.length; i++) {
								var goldEntity = markSpans[i].getAttribute("data-entity0");
								put(entityToElements[0], goldEntity, markSpans[i]);

								var annotatorSpans = markSpans[i].querySelectorAll("tr.annotator, tr.combined");
								// TODO: workaround for highlighting in noAnno
								for(var j=0; j<annotatorSpans.length; j++) {
									var index = annotatorSpans[j].getAttribute("data-index");
									var thisEntity = annotatorSpans[j].getAttribute("data-entity");
									var hasEntity = !isEmpty(goldEntity) || !isEmpty(thisEntity);
									if(hasEntity) {
										annotatorSpans[j].title = annotatorInfo(annotatorSpans[j], goldEntity, thisEntity);
										annotatorSpans[j].onclick = markOnclick;
										put(entityToElements[index], thisEntity, annotatorSpans[j]);
									}
								}
							}

							function evalToSymbol(eval) {
								var result = "";
								switch(eval) {
									// TODO: symbols
									case "correct":
										result = "&#x2714;"; // ✔
										break;
									case "toomuch":
										result = "&#x2718;"; // TODO: another symbol?
										break;
									case "missing":
										result = "&#x2718;"; //"&quest;"; // ❓
										break;
									case "wrong":
										result= "&#x2718;"; // ✘
										break;
								}
								return result;
							}

							// add symbols
							for(i=0; i < markSpans.length; i++) {
								var children = markSpans[i].getElementsByClassName("annotator");
								for(var j=1; j<children.length; j++) {
									// create symbol
									var toolTipText, index, dest, eval;
									eval = children[j].getAttribute("data-eval");
									toolTipText = evalToSymbol(eval);
									
									index = children[j].getAttribute("data-index");
									// symbol after each annotator's mention
									dest = children[j].getElementsByTagName("td")[2];
									
									dest = initElement(dest, 'span', {
										class:"symbols"});
									initElement(dest,'span',{
										class:"symbol single-symbol", 
										"data-index":index}, toolTipText);
								}
							}
						}
						]]>
					</script>
				</body>
			</html>
		</xsl:template>

		<xsl:template match="*">
			<xsl:message terminate="no">
				WARNING: Unmatched element: <xsl:value-of select="name()"/>
			</xsl:message>

			<xsl:apply-templates/>
		</xsl:template>

		<!-- process articles -->
		<xsl:template match="articles/article">
			<h2>
			<xsl:if test="@id=''">Article </xsl:if>
				<xsl:value-of select="@id"/>
			</h2>
			<div class="article grail-body" > <!-- style="line-height: 100%" -->
				<div class="grail-content">
				<xsl:apply-templates select="content"/>
				</div>
				<div class="grail-nav">
				<xsl:apply-templates select="entity-list"/>
				</div>
			</div>
		</xsl:template>

		<!-- process newlines -->
		<xsl:template match="br">
			<br /> &#xA0; <br />
		</xsl:template>

		<!-- transform an xml element to a JavaScript object 
			with attributes name, attr, and children
			which contain their respective XML (transformed) value
			ATTENTION: call this with a single node!
		-->
		<xsl:template match="*" mode="js">
			<xsl:text>{"name":"</xsl:text>
			<xsl:value-of select="name(.)"/>
			<xsl:text>",</xsl:text>
			<xsl:if test="@*">
				<xsl:text> attr:{</xsl:text>
				<!-- attributes -->
				<xsl:for-each select="@*">
					<xsl:text>"</xsl:text><xsl:value-of select="name()"/>
					<xsl:text>": "</xsl:text><xsl:value-of select="."/><xsl:text>",<!--&#xa;--></xsl:text>
				</xsl:for-each>
				<xsl:text>},</xsl:text>
			</xsl:if>
			<xsl:if test="*">
				<xsl:text> children:[</xsl:text>
				<xsl:for-each select="*">
					<xsl:apply-templates select="." mode="js"/>
					<xsl:text>,<!--&#xa;--></xsl:text>
				</xsl:for-each>
				<xsl:text>],</xsl:text>
			</xsl:if>
			<xsl:text>}</xsl:text>
		</xsl:template>


		<xsl:template match="mark">
			<span class="mark">
				<xsl:for-each select='@*'>
					<xsl:attribute name="data-{name()}"><xsl:value-of select="."/></xsl:attribute>
				</xsl:for-each>
				<table class="overlay">
					<tr>
						<!-- opening chain number -->
						<td></td>

						<!-- text -->
						<td style="background-color: white;text-align: center;text-shadow: .5px 0px .0px, -.5px 0px .0px;">
							<span class="collapse">
								<xsl:value-of select="."/>
							</span>
						</td>
						
						<!-- symbol -->
						<td><span class="collapse"/></td>

						<!-- closing chain number -->
						<td></td>
					</tr>
					<tr class="annotator">
						<xsl:attribute name="data-eval">correct</xsl:attribute>
						<xsl:attribute name="data-index">0</xsl:attribute>
						<xsl:attribute name="data-entity"><xsl:value-of select="@entity0"/></xsl:attribute>
						<xsl:for-each select='@*'>
							<xsl:attribute name="data-{name()}"><xsl:value-of select="."/></xsl:attribute>
						</xsl:for-each>

						<td><xsl:call-template name="chainImpl">
								<xsl:with-param name="chain" select="@chain-before0" />
							</xsl:call-template>
						</td>
						<td class="textColumn entity" style="background-color: white; ">G: <xsl:value-of select="@short0" /></td>
						<td></td>
						<td>
								<xsl:call-template name="chainImpl">
									<xsl:with-param name="chain" select="@chain-after0" />
								</xsl:call-template>
						</td>
					</tr>
					<xsl:apply-templates select="*"/>
					<tr class="linespacer">
						<td></td>
						<td class="noselect">&#160;</td>
						<td></td>
						<td></td>
					</tr>
				</table>
			</span>
		</xsl:template>

		<xsl:template match="mark/annotator">
			<tr class="annotator">
			<xsl:attribute name="data-eval"><xsl:value-of select="@eval"/></xsl:attribute>
			<xsl:for-each select='@*'>
				<xsl:attribute name="data-{name()}"><xsl:value-of select="."/></xsl:attribute>
			</xsl:for-each>

			<td>
				<xsl:call-template name="chainImpl">
					<xsl:with-param name="chain" select="@chain-before" />
				</xsl:call-template>
			</td>

			<td class="textColumn entity">
					<!-- A<xsl:value-of select="@index" />:  -->
					<xsl:value-of select="@short" />
				<!--<xsl:value-of select=".." />-->
			</td>

			<td/>

			<td>
				<xsl:call-template name="chainImpl">
					<xsl:with-param name="chain" select="@chain-after" />
				</xsl:call-template>
			</td>
			
			</tr>
		</xsl:template>

		<xsl:template name="chainImpl">
			<xsl:param name="chain"/>

			<xsl:if test="$chain != ''">
				<span class="chain">
					<xsl:value-of select="$chain" />
					<xsl:if test="not($chain)">&#160;</xsl:if>
				</span>
			</xsl:if>
		</xsl:template>

		<xsl:template match="entity-list">
			<div class="entityList">
				<b>Entities:</b><br/>
				<xsl:apply-templates />
			</div>
		</xsl:template>
		<xsl:template match="entity-list/entry">
			<div>
				<span class="entity"><xsl:value-of select="@key" /></span>: 
				<xsl:value-of select="@value" /><br/>
			</div>
		</xsl:template>

		<xsl:template match="evaluation">
			<span class="eval">
				<xsl:attribute name="data-name"><xsl:value-of select="@name"/></xsl:attribute> 
				<xsl:attribute name="data-precision"><xsl:value-of select="@precision"/></xsl:attribute> 
				<xsl:attribute name="data-recall"><xsl:value-of select="@recall"/></xsl:attribute> 
				<xsl:attribute name="data-annotator"><xsl:value-of select="../@id"/></xsl:attribute> 
			</span>
		</xsl:template>

	 	<xsl:template match="evalAnno">
			<xsl:apply-templates />
		</xsl:template>
	</xsl:stylesheet>
	
	<article/>
</articles>
