<?xml version="1.0" encoding="UTF-8" ?>
<?xml-stylesheet type="text/xml" href="#stylesheet"?>
<!DOCTYPE doc [
<!ATTLIST xsl:stylesheet id	ID	#REQUIRED>
<!ATTLIST xsl:stylesheet version	CDATA	#IMPLIED>
<!ATTLIST xsl:stylesheet xmlns:xsl	CDATA	#IMPLIED>
<!ATTLIST xsl:stylesheet xmlns	CDATA	#IMPLIED>
]>
<articles>
	<xsl:stylesheet id="stylesheet"
		version="18.0"
		xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
		xmlns="http://www.w3.org/1999/xhtml"
		>
		<!-- place any xsl:import elements here -->
		<xsl:template match="xsl:stylesheet" />
		<xsl:output method="html" indent="yes" version="5.0" encoding="UTF-8" doctype-public=""/>

		<!-- html skeleton -->
		<xsl:template match="/">
			<xsl:variable name="color1">#e68a2f</xsl:variable>
			<xsl:variable name="color2">#2f31e6</xsl:variable>
			<xsl:variable name="color1and2">#000000</xsl:variable>
			
			<html xmlns:x="http://telecom-paristech.fr/namespace/">
				<head>
					<title>Jecca</title>
					<meta charset="UTF-8" />
					<style>
						.stack {display: inline-flex; flex-direction: column;}
						span { white-space:nowrap; }
						
						/* general style for chain numbers, see style with id "chains" further below */
						.supsub {display:none; }
						.supsub span {font-size: 0.6em; display:inline; position:relative;}
						.superscript { color: darkseagreen; top: -1.5ex; }
						[data-index="1"] .subscript { color: <xsl:value-of select="$color1"/> ; top: -1.75ex; }
						[data-index="2"] .subscript { color: <xsl:value-of select="$color2"/>; top: -1.75ex; }
						.highlight  { text-shadow: .5px 0px .0px, -.5px 0px .0px;} 
						
						/* combine elements according to split attribute */
						[data-split="true"] .combined { visibility: hidden; }
						[data-split="false"] .annotator { visibility: hidden; }
						[data-split="false"] .combined { visibility: visible; }
						[data-split="false"]:hover .combined { visibility: hidden;  }
						[data-split="false"]:hover .annotator { visibility: visible; }

						.highlight .combined { visibility: hidden; }
						.highlight .annotator { visibility: visible; }

						table.overlay { display: inline-block; vertical-align: top; }
						.combined, .combined td { height: 0px; }
						.combined td .collapse {
							height: 0px;
							display: block;
						}

						table.overlay,table.overlay tr,table.overlay td {
							padding: 0px;
							border: 0px;
							margin: 0px;
							border-spacing: 0px;
						}

						table.overlay td:nth-child(1) { text-align: right; }
						table.overlay td:nth-child(2) { text-align: left; }
						table.overlay td:nth-child(4) { text-align: left; }
						
						.combined, [data-index] { color: grey; }
						.symbol, .symbols { display: none; }

  						 .left{
				          display: block;
        				  float:left; 
     					  width:50%;
					    }
					</style>
					<!-- container for annotator visibility rules -->
					<style>
						styleid { content: 'annotatorVisibility'; }
						/*hide annotators by adding a rule like [data-index="1"] { display: none}, show them by removing that rule */
					</style>
					
					<style>
						styleid { content: 'coloring:annotators'; }
						[data-split="false"] .highlight .annotator:first-child { color: <xsl:value-of select="$color1and2"/>; text-shadow: .5px 0px .0px, -.5px 0px .0px;} /* color1and2 */
						[data-split="false"]:hover .highlight .annotator:first-child { color: <xsl:value-of select="$color1"/>; }
						
						[data-index="1"]:not([data-eval=""]).highlight { color: <xsl:value-of select="$color1"/>; }
						[data-index="2"]:not([data-eval=""]).highlight { color: <xsl:value-of select="$color2"/>; }
					</style>
					<style>
						styleid { content: 'coloring:noAnno'; }
						[data-index].highlight  { display: none; }
						.combined  { color:DarkSlateBlue;}
						[data-split] .combined { visibility: visible; }
						.symbol, .symbols { display: none; }
					</style>
					<style>
						styleid { content: 'coloring:eval'; }
						[data-index="1"].highlight .symbol { color: <xsl:value-of select="$color1"/>; }
						[data-index="2"].highlight .symbol { color: <xsl:value-of select="$color2"/>; }
						/* styles for evaluation */
						[data-eval="correct"].highlight { color: green; }
						[data-eval="toomuch"].highlight { color: red; }
						[data-eval="missing"].highlight { color: DarkSlateBlue; }
						[data-eval="wrong"].highlight { color: red; }
					</style>
					<style>
						styleid { content: 'coloring:diff'; }
						[data-split="false"] .highlight.annotator { color: green; }
						[data-split="true"] .highlight.annotator { color: red; }
					</style>
					<style>
						styleid { content: 'coloring:chains'; }
						.highlight.rightchain.annotator { color: green; }
						.highlight.wrongchain.annotator { color: red; }
						.highlight.rightchain.wrongchain.annotator { color: black; }
						.highlight.selected { /*border: solid black 1px;*/ text-decoration: underline; }
					</style>
					<style>
						styleid { content: 'highlighting:enabled'; }
						[data-index] { color: gray; }
						.highlightMode { display: initial; }
						.defaultMode { display: none; }
					</style>
					<style>
						styleid { content: 'highlighting:disabled'; }
						.combined { text-shadow: .5px 0px .0px, -.5px 0px .0px; color: black; }
						.highlightMode { display: none; }
						.defaultMode { display: initial; }
					</style>
					<style>
						styleid { content: 'symbols'; }
						.symbols { display: initial; }
						.symbol { display: initial; position: relative; bottom: 1ex; font-size: small; }
						/*[data-split="false"] .symbols { position: relative; }
						[data-split="false"] .symbols .single-symbol { position: absolute; left: 0px; }*/
					</style>
	
					<style>
						styleid { content: 'chains'; }
						.supsub {display:inline-flex; flex-direction: column;
						vertical-align:middle; height:1ex; user-select: none;
						-moz-user-select: none; -khtml-user-select: none; }
					</style>
				
					<style>
						[data-eval=""] { color: black; }
						
						body { height: 100vh; padding: 0px; margin: 0px;}
						/* using HolyGrail from https://philipwalton.github.io/solved-by-flexbox/demos/holy-grail/ */
						.grail, .grail-body { display: flex; flex-direction: column; }
						.grail-content { flex: 1; }
						.grail-nav { order: 1; }
						@media ( min-width : 568px) {
							.grail-body { flex-direction: row; flex: 1; }
							.grail-content { flex: 1; }
							.grail-nav { /* 10em is the width of the columns */ flex: 0 0 10em; margin: 0 10px 0 10px ;}
						}
						#mentionTable{
							margin-right: 3px;
						}
						#content {
							/* margin-right: 10vw; */
							margin-left: 1vw; 
							border-style: none;
							height: 100%;
							max-height: 70vh;
							overflow: auto;
							flex: 1 1 auto;
						}
						@media( min-width : 568px) {
							#content { max-height: 100vh; }
						}
						#eval {
							/*margin-right: 10vw;
							height: 25%;
							overflow: auto;*/
						}
						#wrapper {
							display: flex;
							flex-flow: column;
							height: 100vh;
						}
						/*#wrapper {	
							left:0px;
							margin-right: 17vw;
							/*margin-right: 15vw;*/
							height: 100%;
							overflow: auto;
						}
						#wrapper2 {	
							margin-right: 5px;
							position: fixed;
							top:5.5vw;	
							right:0px;
							/*height:100vh;*/
							width: 17vw;
							}*/

						#annotators {
						/*	margin-right: 2px;
							position: fixed;
							top:5.5vw;
							left:3px;
							right:0px;
							/*height:100vh;*/
							width: 15vw;*/
						}
						#control {
							position: fixed;
							top:3.5vw;
							right:0px;
							height: 100%;
						} 

						/*style for menu navigator*/
						.titlebar {
							list-style-type: none;
							margin: 0;
							padding: 0.5em;
							overflow: hidden;
							background-color: #333;
							color: white;
							font-size: 1.5em;
							font-weight: bold;
						}

						li {
							float: left;
						}


						.show {display:block;}

						select.menu {
							width: 94%;
							padding: 3%;
							border:0px;
							outline:0px;
							font:inherit;
						}
						select.metric {
							border:0px;
							outline:0px;
							font:inherit;
						}

						table, th, td {
							border: 1px solid black;
							border-collapse: collapse;
							text-align: center;
						}
						th, td {
							padding: 5px;
						}
					</style>

					<script type="text/javascript">
						<![CDATA[
							// ADD CODE INSIDE NEXT IF BLOCK
							function isUndefined(v) {
								return typeof v === "undefined";
							}
							// execute only once, see mozilla-bug-380828
							if(!isUndefined(document.getElementsByName)) {

								/** Take Json output from XML and collapse it, i.e. make attributes and children elements accessible by r["name"] and r["name"][childindex] */
								function collapseXMLJson(o) {
									var r = {};
									if(!isUndefined(o["attr"])) {
										var keys = Object.keys(o["attr"]);
										for(var i=0; i<keys.length; i++) {
											r[keys[i]] = o["attr"][keys[i]];
										}
									}
									if(!isUndefined(o["children"])) {
										var cs = o["children"];
										for(var i=0; i<cs.length; i++) {
											var name = cs[i]["name"];
											if(isUndefined(r[name])) {
												r[name] = new Array();
											}
											r[name].push(collapseXMLJson(cs[i]));
										}
									}
									return r;
								}

								annotators = collapseXMLJson(]]><xsl:apply-templates select="articles/annotators" mode="js"/><![CDATA[)["annotator"];
								metrics = collapseXMLJson(]]><xsl:apply-templates select="articles/metrics" mode="js"/><![CDATA[)["annotator"];
							}
						]]>
					</script>
				</head>
				<body class="grail">
					<div class="grail-body">
					<div id="wrapper" class="grail-content">
						<div class="titlebar" style="position: relative">
								Jecca
								<div style="position: absolute; top:0; bottom:0; right:0;">
								<svg xmlns="http://www.w3.org/2000/svg" style="position: absolute; top:calc(+15%);right:0;" height="70%" viewBox="0 0 76 50">
									<ellipse cx="38" cy="27" fill="#fff" stroke="#000" stroke-width=".7" rx="24" ry="22"/>
									<ellipse cx="32" cy="25" ry="2" rx="2"/>
									<ellipse cx="44" cy="25" ry="2" rx="2"/>
									<g stroke="#000">
										<g fill="none">
											<path d="M35 27s2-12-3-12c-6 0-7 8-4 12 1 2 7 0 7 0z"/>
											<path d="M40 27s-2-12 4-12c5 0 6 9 4 12-2 2-8 0-8 0z"/>
											<path d="M38 34c-5 6-10 3-10 3"/>
											<path d="M38 34c5 6 10 3 10 3"/>
										</g>
										<g fill="#fff">
											<path d="M36 30c-2 0 2 3 2 3s5-3 2-3z" />
											<path d="M37 7C26-1 25 1 23 1c-1 1-2 10-3 15"/>
											<path d="M20 16c0-17 1-20 13-5"/>
											<path d="M37 7c11-8 13-6 15-6 1 1 2 10 2 15"/>
											<path d="M54 16c0-17-1-21-12-6"/>
										</g>
										<g stroke-width=".5">
											<path d="M47 34l27 6"/>
											<path d="M47 31l26-8"/>
											<path d="M47 32l29-2"/>
											<path d="M30 34L2 40"/>
											<path d="M29 31L4 23"/>
											<path d="M30 33L0 31"/>
										</g>
									</g>
								</svg>
								</div>
						</div>
					
						<div id="content">
							<xsl:apply-templates /> 
						</div>
					</div>
					<div id="wrapper2" class="grail-nav">
						<div>
							<h3 style="background-color: #333;color:white;"> Options </h3>
							<!--<select class='menu' id="optDoc" size="2" onchange="document.getElementById('content').onclick()"> 
								<option value="allArticles" selected="true">All articles</option> 
								<option value="onePerTime">One at a time</option> 
							</select>-->

							<select class='menu' id="optColor" size="2" onchange="updateMode()" style="display: none;"> 
								<option value="annotator">annotator</option> 
								<option value="eval" selected="true">evaluation</option> 
							</select>
							Combine same <select id="optCombine" size="1" onchange="updateMode()"> 
								<option value="eval" selected="true">colors</option> 
								<option value="entity">entities</option> 
							</select>
							<br/>

							<label><input id="showSymbols" type="checkbox" name="symbols"  onchange="cssStyle['symbols'].disabled = !this.checked; updateMode();"/>Show symbols</label>
							<br/>
							<label><input id="showChains" type="checkbox" name="chains" onchange="cssStyle['chains'].disabled = !this.checked; updateMode();"/>Show entity numbers</label>
						</div>
						<div>
							<h3 style="background-color: #333;color:white;"> Annotators </h3>
						</div>
						<div id="annotators" xmlns="http://www.w3.org/1999/xhtml">
						</div>	
						<div style='border-style: none;' >	
							<div id="eval" >	
								<h3 style="background-color: #333;color:white;"> Evaluation </h3>
								<div  id="evalTableSelection"> 
									<div   id="selectDiv" >
		 
									</div>
									<div  id="tableDiv"  >
		    
									</div>
									
								</div>
								<!-- <div class="left" id="diagram">
		  							<svg id="mySVG" height="240" width="500" xmlns="http://www.w3.org/2000/svg" >
										<line class="default"  x1="100" y1="10" x2="100" y2="210" style="stroke:rgb(0,0,0);stroke-width:1" />
										<line  class="default"  x1="100" y1="210" x2="300" y2="210" style="stroke:rgb(0,0,0);stroke-width:1" />
										<text class="default" x="80" y="60" fill="black">P</text>
										<text  class="default"  x="290" y="230" fill="black">R</text>
									</svg>
								</div> -->
							</div>
						</div>
						<div style="font-size: 70%; margin-top: 2ex;">
							* colors:
							<span class="defaultMode"><br/>
								<span data-eval="correct">correct</span><br/>
								<span data-eval="wrong">wrong</span><br/>
								<span data-eval="missing">missing</span>
							</span>
							<span class="highlightMode"><br/>
								<span class="annotator highlight rightchain">in right chain</span><br/>
								<span class="annotator highlight wrongchain">in wrong chain</span><br/>
								<span class="annotator highlight rightchain wrongchain">in both chains</span>
							</span>

						</div>
					</div>
					</div>
					
					<script type="text/javascript">
						<![CDATA[
						// ADD CODE INSIDE NEXT IF BLOCK
						function isUndefined(v) {
							return typeof v === "undefined";
						}
						// execute only once, see mozilla-bug-380828
						if(!isUndefined(document.getElementsByName)) {
							var content = document.getElementById("content");
							
							/** adapted from http://stackoverflow.com/a/19662291/1562506
								usage example:
								var img  = initElement(svg,'circle',{
									cx:100, cy:150, r:22,
									fill:'black'});
							*/
							function initElement( dad, name, attrs, text ){
								var doc = dad.ownerDocument;
								var svg = dad.ownerSVGElement || dad;
								var ns = initElement.$NAMESPACES;
								var defaultNS = svg.namespaceURI;
								if (!ns){
									ns = initElement.$NAMESPACES = {};
									for (var a=svg.attributes,i=a.length;i--;) if (a[i].prefix=='xmlns') ns[a[i].localName] = a[i].value;
								}
								var p = name.split(':');
								var el = p[1] ? doc.createElementNS(ns[p[0]],p[1]) : doc.createElementNS(defaultNS,name);
								for (var a in attrs){
									p = a.split(':');
									if (p[1]) el.setAttributeNS(ns[p[0]],p[1],attrs[a]);
									else      el.setAttributeNS(null,a,attrs[a]);
								}
								if (text) {
									el.insertAdjacentHTML('beforeend', text);
								}
								return dad.appendChild(el);
							}


							function elementLabeling(label, forElementId, divId){
								var newlabel = document.createElement("label");
								newlabel.setAttribute("for",forElementId);
								newlabel.innerHTML = label;
								divId.appendChild(newlabel);
							}
							

							/*To dynamically create the annotator checkboxes*/
							for(var k=1;k<annotators.length;k++){
								initElement(document.getElementById('annotators'),'input',{type:'checkbox', id:"checkTag"+annotators[k]["id"], name:'annotator'+annotators[k]["id"] ,value:"annotator"+annotators[k]["id"], onchange:"updateMode();", checked:'checked'});
								elementLabeling("Anno "+annotators[k]["id"],"checkTag"+annotators[k]["id"],document.getElementById('annotators'));
								if(k<annotators.length-1){
									var br = document.createElement('br');
									document.getElementById('annotators').appendChild(br);
								}
							}
							
							/* When the user clicks on the button, 
							toggle between hiding and showing the dropdown content */
							function dropDown(menuId) {
								document.getElementById(menuId).classList.toggle("show");
							}

							// Close the dropdown menu if the user clicks outside of it
							window.onclick = function(event) {
							  if (!event.target.matches('.dropbtn')) {

								var dropdowns = document.getElementsByClassName("dropdown-content");
								var i;
								for (i = 0; i < dropdowns.length; i++) {
								  var openDropdown = dropdowns[i];
								  if (openDropdown.classList.contains('show')) {
									openDropdown.classList.remove('show');
								  }
								}
							  }
							 }

							if(!isUndefined(metrics)) {
								var metricNames = new Array();
								for(var i=0;i<metrics[0].metric.length;i++) {
									var name = metrics[0].metric[i].name;
									metricNames.push(name);
								}
								var selectElem = initElement(document.getElementById('selectDiv'),'select',{id:'metricsSel', class:'metric', onchange:'fillEvalTable(this.value);'});

								/*To dynamically create the metrics select*/
								for(var j=0;j<metricNames.length;j++){
									var name = metrics[0].metric[j].name;
									var option = initElement(selectElem,'option',{value: name});
									option.innerHTML=name;
								}
							}

							function fillEvalTable(metric){
								var table = document.getElementById("evalTable");
								var headerArray=["Annotator", "precision", "recall"];
								if(document.getElementById("evalTable")!=null){
 									table.innerHTML = "";
 									var header = table.createTHead();
									var row = header.insertRow(0);
									for(i=0;i<headerArray.length;i++){
										var cell = row.insertCell(i);
										cell.innerHTML = "<b>"+headerArray[i] +"</b>";
									}
								}
								
								if(document.getElementById("evalTable")==null){
									table=document.createElement("table");
									table.setAttribute("id", "evalTable");	
									document.getElementById("tableDiv").appendChild(table);
									var header = table.createTHead();
									var row = header.insertRow(0);
									for(i=0;i<headerArray.length;i++){
										var cell = row.insertCell(i);
										cell.innerHTML = "<b>"+headerArray[i] +"</b>";
									}
								}
								
								for (var i=0;i<metrics.length;i++) {
									var anno=annotators[i]["id"];
									var row= table.insertRow(-1);
									var annoCell = row.insertCell(0);
									annoCell.innerHTML = "Anno "+anno;
									var precisionCell=null;
									var recallCell=null;
									for(var j=0;j<metrics[i].metric.length;j++){
										var map=metrics[i].metric[j];
										if(map["name"]==metric){
											precisionCell= row.insertCell(1);
											precisionCell.innerHTML = map["precision"];
											recallCell = row.insertCell(2);
											recallCell.innerHTML = map["recall"];
										}
									}
								 	if(precisionCell== null && recallCell==null){
								 		table.deleteRow(table.getElementsByTagName("TR").length-1);
									}	
								}
							
								var p = highlightCell(1);
								var r = highlightCell(2);
							}

							function highlightCell(column){
								var  max, rowNo = null;
								var table = document.getElementById("evalTable");
								var a = table.getElementsByTagName("TR");
								for (var i=1; i<a.length; i++) {
									var td = a[i].childNodes[column];
									if(!isUndefined(td)) {
										var val = td.innerHTML;
										if (rowNo == null || val > max) {
											max = val;
											rowNo = i;
										}
									}
								}
								if(rowNo != null) {
									var td = a[rowNo].childNodes[column];
									td.style.backgroundColor = "yellow";
								}
							}
							if(!isUndefined(metricNames)) {
								fillEvalTable(metricNames[0]);
							}
							else {
								document.getElementById("eval").style.display = "none";
							}
							
							function updateDiagram(metric){   
								var svg =  document.getElementById('mySVG');
								if(annotators.length==0 || metrics.length==0 ){
									console.log("No annotators or metrics for evaluation!");
								}
								var childrenNodes = svg.childNodes;
							
								
								for (var l=childrenNodes.length-1;l>=0;l--) {
						
							 		if(childrenNodes[l].classList.contains("default")){
							 			continue;
							 		}
								  	svg.removeChild(childrenNodes[l]);
							 		
								}
								
								for (var i=0;i<annotators.length;i++) {
								 	var anno=annotators[i]["id"];
								 	var precision;
								 	var recall;
 								 	for(var j=0;j<evalPerAnno.length;j++){

										var evMap=evalPerAnno[j];
										
								 		if(evMap.getAttribute("data-annotator")==anno && evMap.getAttribute("data-name")==metric){
								 			precision = evMap.getAttribute("data-precision");
								 			recall = evMap.getAttribute("data-recall");
								 		}
								 	}
								 	 
								 	var precisionSVG=250-Number(precision)*20;
								 	var recallSVG=100+Number(recall)*20;
								 	 
								 	var textSVG  = initElement(svg,'text',{x:precisionSVG, y:recallSVG, fill:'black', style:'font-size:100%', class:"new"});
								 	textSVG.innerHTML=anno;
								 	initElement(svg,'circle',{cx:precisionSVG, cy:recallSVG, r:1, fill:'black'});

								}
							} 
							/*updateDiagram(metrics[0]);*/

							/* fetch named css styles and store them in a map */
							var cssStyle = new Array();
							var cssGroup = new Array();
							var cssLen = document.styleSheets.length;
							for(var i=0; i<cssLen; i++) {
								var sheet = document.styleSheets[i];
								id = sheet.cssRules[0].cssText;
								if(isUndefined(id)) continue;
								var found = id.match(/^styleid.*content:\s*["']([^"']*)["']/);
								if(!found || found.length != 2) continue;
								id = found[1];
								cssStyle[id] = sheet;
								var colonPos = id.indexOf(":");
								if(colonPos >= 0) {
									var groupName = id.substr(0, colonPos);
									if(isUndefined(cssGroup[groupName])) {
										cssGroup[groupName] = new Array();
									}
									cssGroup[groupName][id.substr(colonPos+1)] = sheet;
									sheet.disabled = true;
								}
							}
							// transform coloring to cssGroup highlight
							var keys = Object.keys(cssGroup["coloring"]);
							cssGroup["coloringHighlight"] = new Array();
							for(var i=0; i<keys.length; i++) {
								var name = keys[i];
								sheet = cssGroup["coloring"][name];
								cssGroup["coloringHighlight"][name] = sheet;
								sheetCopy = document.createElement("style");
								sheetCopy.type = 'text/css';
								cssCode = '';
								for(var j=0; j<sheet.cssRules.length; j++) {
									// generate new rule
									nr = sheet.cssRules[j].cssText;
									nr = nr.replace(".highlight", "");
									cssCode += nr;
								}
								sheetCopy.innerHTML = cssCode;
								document.getElementsByTagName('head')[0].appendChild(sheetCopy);
								cssGroup["coloring"][name] = sheetCopy;
							}

							cssStyle["symbols"].disabled = !document.getElementById("showSymbols").checked;
							cssStyle["chains"].disabled = !document.getElementById("showChains").checked;
							
							/* enable coloring with the given id and disable all the others */
							function selectStyle(styles, id) {
								var keys = Object.keys(styles);
								for(var i=0; i<keys.length; i++) {
									styles[keys[i]].disabled = keys[i] !== id;
								}
							}

							var markSpans = document.querySelectorAll("span.mark");
							function updateMode() {
								var coloringGroup;
								var highlightMode = content.querySelectorAll(".highlight").length > 0;
								var optColor = document.getElementById("optColor");
								if(highlightMode) {
									coloringGroup = "coloringHighlight";
									selectStyle(cssGroup["highlighting"], "enabled");
									selectStyle(cssGroup["coloring"], null);
									selectStyle(cssGroup[coloringGroup], "chains");
								} else {
									coloringGroup = "coloring";
									selectStyle(cssGroup["highlighting"], "disabled");
									selectStyle(cssGroup["coloringHighlight"], null);
									selectStyle(cssGroup[coloringGroup], optColor.options[optColor.selectedIndex].value);
								}

								var sheet = cssStyle["annotatorVisibility"];
								while(sheet.cssRules.length>0) {
									sheet.deleteRule(0);
								}
								function isEnabled(index) {
									if(index==0) return false;
									return document.getElementById('checkTag' + index).checked;
								}
								var enabledTaggers = new Array();
								for(var i=1; i<annotators.length; i++) {
									if(isEnabled(annotators[i]["id"])) {
										enabledTaggers.push(annotators[i]["id"]);
									}
								}
								if(enabledTaggers.length == 0) {
									selectStyle(cssGroup[coloringGroup], "noAnno");
								}
								else {
									for(var i=0; i<annotators.length; i++) {
										if(!isEnabled("" + i)) {
											sheet.insertRule("[data-index='" + i + "'] { display: none; }", 0);
										}
									}
									for(var i=0; i<markSpans.length; i++) {
										if(enabledTaggers.length == 1) {
											markSpans[i].setAttribute("data-split", "true");
										}
										else {
											var base = null;
											var annotatorSpans = markSpans[i].getElementsByClassName("annotator");
											// TODO: fix bug if wrongly tagged by second annotator
											
											var optCombine = document.getElementById("optCombine");
											var combineAttribute = "data-" + optCombine.options[optCombine.selectedIndex].value;
											for(var j=0; j<annotators.length; j++) {
												if(isEnabled("" + j)) {
													// always split highlighted spans
													if(annotatorSpans[j-1].classList.contains("highlight")) {
														base = "split";
														break;
													}
													var val = annotatorSpans[j-1].getAttribute(combineAttribute) || "";
													if( (base == null ? val : base) != val) {
														base = "split";
														break;
													}
													base = base || val;
												}
											}
											markSpans[i].setAttribute("data-split", base == "split");
										}
									}
								}
							}
							updateMode();

							/* add a value to the values of a key (in a multi-map) */
							function put(map, key, value) {
								if(key != null) {
									list = map[key] || (map[key] = new Array());
									list.push(value);
								}
							}
							
							/* helper to insert nodes in DOM*/
							function after(newNode, refNode) {
								if(isUndefined(refNode) || isUndefined(newNode)) return false;
								refNode.parentNode.insertBefore(newNode, refNode.nextSibling);
							}
							function replace(newNode, refNode) {
								if(isUndefined(refNode) || isUndefined(newNode)) return false;
								return refNode.parentNode.replaceChild(newNode, refNode);
							}

							function ancestorWithClass(element, clazz) {
								var ancestor = element;
								while((ancestor = ancestor.parentElement) && !ancestor.classList.contains(clazz));
								return ancestor;
							}

							function removeClass(element, clazz) {
								selection = element.querySelectorAll("." + clazz)
								for(i=0; i<selection.length; i++) {
									selection[i].classList.remove(clazz);
								}
							}

							/* deselect highlight on click */
							content.onclick = function() {
								removeClass(content, "highlight");
								updateMode();
							}
							/* highlight chains on click on a mention */
							function markOnclick(e) {
								e.stopPropagation();
								// check whether user has selected this element
								var wasHighlighted = ancestorWithClass(e.target, "highlight") != null;
								// deselect
								removeClass(content, "selected");
								removeClass(content, "highlight");
								removeClass(content, "rightchain");
								removeClass(content, "wrongchain");
								if(wasHighlighted) {
									updateMode();
									return;
								}
								var ancestor = ancestorWithClass(e.target, "annotator");
								if(ancestor == null) return;
								ancestor.classList.add("selected");
								var index = ancestor.getAttribute("data-index");
								var thisEntity = ancestor.getAttribute("data-entity");
								var goldEntity = ancestorWithClass(e.target, "mark").getAttribute("data-entity0");
								// determine which elements to select
								var elements = [].concat(entityToElements[index][thisEntity]);
								elements = elements.concat(entityToElements[0][goldEntity]);
								// highlight selection
								for(i=0; i < elements.length; i++) {
									if(!isUndefined(elements[i])) {
										var annotatorSpans = [elements[i]];
										if(!elements[i].classList.contains("annotator")) {
											annotatorSpans = elements[i].querySelectorAll(".annotator[data-index='" + index + "']");
										}
										for(var j=0; j<annotatorSpans.length; j++) {
											var annotatorSpan = annotatorSpans[j];
											annotatorSpan.classList.add("highlight");
											if(ancestorWithClass(annotatorSpan, "mark").getAttribute("data-entity0") == goldEntity) {
												annotatorSpan.classList.add("rightchain");
											}

											if(annotatorSpan.getAttribute("data-entity") == thisEntity && ancestor.getAttribute("data-eval") != "correct") {
												annotatorSpan.classList.add("wrongchain");
											}
										}
									}
								}
								updateMode();
							}

							/* generate tooltip */
							function annotatorInfo(element, em0, emI) {
								var eval = element.getAttribute("data-eval")
								switch (eval) {
									case "correct":
										result = "correctly annotated with '" + emI + "'";
										if(isUndefined(emI)) console.log(new Error().stack);
										break;
									case "toomuch":
										result = "should not be annotated, found '" + emI + "'";
										break;
									case "missing":
										result = "should have been annotated with '" + em0 + "'";
										break;
									case "wrong":
										result = "should have been '" + em0 + "', but found '" + emI + "'";
										break;
									default:
										result = "not annotated";
								}
								return result;
							}

							function isEmpty(n) {
								return isUndefined(n) || n == null || n == "";
							}

							// map from entity to annotator to element
							var entityToElements = new Array();
							for(var i=0; i<annotators.length; i++) {
								entityToElements.push(new Array());
							}
							/* initialize annotator spans (onclick, associated entities, annotator info) */
							for(var i=0; i<markSpans.length; i++) {
								var goldEntity = markSpans[i].getAttribute("data-entity0");
								put(entityToElements[0], goldEntity, markSpans[i]);

								var annotatorSpans = markSpans[i].querySelectorAll("tr.annotator, tr.combined");
								// TODO: workaround for highlighting in noAnno
								for(var j=0; j<annotatorSpans.length; j++) {
									var index = annotatorSpans[j].getAttribute("data-index");
									var thisEntity = annotatorSpans[j].getAttribute("data-entity");
									var hasEntity = !isEmpty(goldEntity) || !isEmpty(thisEntity);
									if(hasEntity) {
										annotatorSpans[j].title = annotatorInfo(annotatorSpans[j], goldEntity, thisEntity);
										annotatorSpans[j].onclick = markOnclick;
										put(entityToElements[index], thisEntity, annotatorSpans[j]);
									}
								}
							}

							// add symbols
							for(i=0; i < markSpans.length; i++) {
								var split = markSpans[i].getAttribute("data-split");
								var children = markSpans[i].getElementsByClassName("annotator");
								
								var anchor = document.createElement("span");
								anchor.classList.add("grouped-symbols");
								var firstFontNode = markSpans[i].getElementsByTagName("td")[2].getElementsByClassName("collapse")[0];
								
								var parent = document.createElement("span");
								parent.classList.add("symbols");
								parent.appendChild(anchor);
								firstFontNode.appendChild(parent);
								
								for(var j=0; j<children.length; j++) {
									// create symbol
									var toolTipText, index, dest, eval;
									eval = children[j].getAttribute("data-eval");
									switch(eval) {
										// TODO: symbols
										case "correct":
											toolTipText = "&#x2714;"; // ✔
											break;
										case "toomuch":
											toolTipText = "&#x2718;"; // TODO: another symbol?
											break;
										case "missing":
											toolTipText = "&quest;"; //"&#x2753;"; // ❓
											break;
										case "wrong":
											toolTipText= "&#x2718;"; // ✘
											break;
										default:
											toolTipText = "";
									}
									index = children[j].getAttribute("data-index");
									// symbol after each annotator's mention
									dest = children[j].getElementsByTagName("td")[2];
									
									if(!isUndefined(dest)) {
										if(j != 0) {
											dest = initElement(dest, 'span', {
												class:"symbols"});
										} else {
											initElement(parent,'span',{
												class:"symbol single-symbol", 
												}, toolTipText);
										}
										initElement(dest,'span',{
											class:"symbol single-symbol", 
											"data-index":index}, toolTipText);
									}
								}
							}
						}
						]]>
					</script>
				</body>
			</html>
		</xsl:template>

		<xsl:template match="*">
			<xsl:message terminate="no">
				WARNING: Unmatched element: <xsl:value-of select="name()"/>
			</xsl:message>

			<xsl:apply-templates/>
		</xsl:template>

		<!-- process articles -->
		<xsl:template match="articles/article">
			<h2>
			<xsl:if test="@id=''">Article </xsl:if>
				<xsl:value-of select="@id"/>
			</h2>
			<div>
				<xsl:apply-templates />
			</div>
		</xsl:template>

		<!-- process newlines -->
		<xsl:template match="br">
			<br /> &#xA0; <br />
		</xsl:template>

		<!-- transform an xml element to a JavaScript object 
			with attributes name, attr, and children
			which contain their respective XML (transformed) value
			ATTENTION: call this with a single node!
		-->
		<xsl:template match="*" mode="js">
			<xsl:text>{"name":"</xsl:text>
			<xsl:value-of select="name(.)"/>
			<xsl:text>",</xsl:text>
			<xsl:if test="@*">
				<xsl:text> attr:{</xsl:text>
				<!-- attributes -->
				<xsl:for-each select="@*">
					<xsl:text>"</xsl:text><xsl:value-of select="name()"/>
					<xsl:text>": "</xsl:text><xsl:value-of select="."/><xsl:text>",<!--&#xa;--></xsl:text>
				</xsl:for-each>
				<xsl:text>},</xsl:text>
			</xsl:if>
			<xsl:if test="*">
				<xsl:text> children:[</xsl:text>
				<xsl:for-each select="*">
					<xsl:apply-templates select="." mode="js"/>
					<xsl:text>,<!--&#xa;--></xsl:text>
				</xsl:for-each>
				<xsl:text>],</xsl:text>
			</xsl:if>
			<xsl:text>}</xsl:text>
		</xsl:template>


		<xsl:template match="mark">
			<span class="mark">
				<xsl:for-each select='@*'>
					<xsl:attribute name="data-{name()}"><xsl:value-of select="."/></xsl:attribute>
				</xsl:for-each>
				<table class="overlay">
					<tr class="combined">
						<!-- opening chain number -->
						<td>
							<span class="collapse">
								<xsl:call-template name="chainImpl">
									<xsl:with-param name="chain0" select="@chain-before0" />
								</xsl:call-template>
							</span>
						</td>

						<!-- text -->
						<td>
							<span class="collapse">
								<xsl:value-of select="."/>
							</span>
						</td>
						
						<!-- symbol -->
						<td><span class="collapse"/></td>

						<!-- closing chain number -->
						<td>
							<span class="collapse">
								<xsl:call-template name="chainImpl">
									<xsl:with-param name="chain0" select="@chain-after0" />
								</xsl:call-template>
							</span>
						</td>
					</tr>
					<xsl:apply-templates select="*"/>
				</table>
			</span>
		</xsl:template>

		<xsl:template match="mark/annotator">
			<tr class="annotator">
			<xsl:attribute name="data-eval"><xsl:value-of select="@eval"/></xsl:attribute>
			<xsl:for-each select='@*'>
				<xsl:attribute name="data-{name()}"><xsl:value-of select="."/></xsl:attribute>
			</xsl:for-each>

			<td>
				<xsl:call-template name="chainImpl">
					<xsl:with-param name="chain0" select="../@chain-before0" />
					<xsl:with-param name="chain" select="@chain-before" />
				</xsl:call-template>
			</td>

			<td>
				<xsl:value-of select=".." />
			</td>

			<td/>

			<td>
				<xsl:call-template name="chainImpl">
					<xsl:with-param name="chain0" select="../@chain-after0" />
					<xsl:with-param name="chain" select="@chain-after" />
				</xsl:call-template>
			</td>
			
			</tr>
		</xsl:template>

		 
	

		<xsl:template name="chainImpl">
			<xsl:param name="chain0"/>
			<xsl:param name="chain"/>

			<xsl:if test="$chain0 != '' or $chain != ''">
				<span class="supsub">
					<span class="superscript">
						<xsl:value-of select="$chain0" />
						<xsl:if test="not($chain0)">&#160;</xsl:if>
					</span>
					<span class="subscript">
						<xsl:value-of select="$chain" />
						<xsl:if test="not($chain)">&#160;</xsl:if>
					</span>
				</span>
			</xsl:if>

		</xsl:template>


		<xsl:template match="evaluation">
			<span class="eval">
				<xsl:attribute name="data-name"><xsl:value-of select="@name"/></xsl:attribute> 
				<xsl:attribute name="data-precision"><xsl:value-of select="@precision"/></xsl:attribute> 
				<xsl:attribute name="data-recall"><xsl:value-of select="@recall"/></xsl:attribute> 
				<xsl:attribute name="data-annotator"><xsl:value-of select="../@id"/></xsl:attribute> 
			</span>
		</xsl:template>

	 	<xsl:template match="evalAnno">
			<xsl:apply-templates />
		</xsl:template>
	</xsl:stylesheet>
	
	<annotators>
	<annotator id='0' file='doc/examples/tutorial.xml'/>
	<annotator id='1' file='doc/examples/tutorial-1.xml'/>
	<annotator id='2' file='doc/examples/tutorial-2.xml'/>
</annotators>
<metrics>
<annotator id='0'>
    <metric name='bcub (macro)' recall='0.41666666' precision='0.41666666'/>
    <metric name='bcub (micro)' recall='0.71428573' precision='0.71428573'/>
    <metric name='ceafe (macro)' recall='0.4166667' precision='0.4166667'/>
    <metric name='ceafe (micro)' recall='0.7777778' precision='0.7777778'/>
    <metric name='ceafm (macro)' recall='0.41666666' precision='0.41666666'/>
    <metric name='ceafm (micro)' recall='0.71428573' precision='0.71428573'/>
    <metric name='muc (macro)' recall='0.1875' precision='0.1875'/>
    <metric name='muc (micro)' recall='0.75' precision='0.75'/>
</annotator>
<annotator id='1'>
    <metric name='bcub (macro)' recall='0.5' precision='0.5'/>
    <metric name='bcub (micro)' recall='1.0' precision='1.0'/>
    <metric name='ceafe (macro)' recall='0.5' precision='0.5'/>
    <metric name='ceafe (micro)' recall='1.0' precision='1.0'/>
    <metric name='ceafm (macro)' recall='0.5' precision='0.5'/>
    <metric name='ceafm (micro)' recall='1.0' precision='1.0'/>
    <metric name='muc (macro)' recall='0.25' precision='0.25'/>
    <metric name='muc (micro)' recall='1.0' precision='1.0'/>
</annotator>
</metrics>
  <article id='Tutorial'>
Welcome to the JESICAT tutorial. Have a look at the words in boldface like <mark  split='false' entity0='Obama; 1; Barack_Obama' chain-before0='(1' chain-after0='1)'><annotator index='1' entity='Barack_Obama' eval='correct' chain-before='(1' chain-after='1)'/>
<annotator index='2' entity='Barack_Obama' eval='correct' chain-before='(1' chain-after='1)'/>
Obama</mark>
, which refers to the president. We call this &quot;combined view&quot;. When you move over it with your mouse cursor, you can see &quot;Obama&quot; twice, one line for every annotator. But we can also mean <mark  split='false' entity0='Obama; 1; Barack_Obama' chain-before0='(1,(2' chain-after0='1)'><annotator index='1' entity='Barack_Obama' eval='correct' chain-before='(1,(2' chain-after='1)'/>
<annotator index='2' entity='Barack_Obama' eval='correct' chain-before='(1,(2' chain-after='1)'/>
his</mark>
<mark  split='false' entity0='his wife; 2; Michelle_Obama' chain-before0='' chain-after0='2)'><annotator index='1' entity='Michelle_Obama' eval='correct' chain-before='' chain-after='2)'/>
<annotator index='2' entity='Michelle_Obama' eval='correct' chain-before='' chain-after='2)'/>
 wife</mark>
 with <mark  split='true' entity0='his wife; 2; Michelle_Obama' chain-before0='(2' chain-after0='2)'><annotator index='1' entity='Barack_Obama' eval='wrong' chain-before='(1' chain-after='1)'/>
<annotator index='2' entity='Michelle_Obama' eval='correct' chain-before='(2' chain-after='2)'/>
Obama</mark>
. We call this &quot;split view&quot;. One annotator got it wrong and in that case you&apos;ll aways see the word multiple times. Move your mouse on top of a mention and a tooltip will give you details about it.  Click on the first line of &quot;<mark  split='true' entity0='his wife; 2; Michelle_Obama' chain-before0='(2' chain-after0='2)'><annotator index='1' entity='Barack_Obama' eval='wrong' chain-before='(1' chain-after='1)'/>
<annotator index='2' entity='Michelle_Obama' eval='correct' chain-before='(2' chain-after='2)'/>
Michelle Obama</mark>
&quot; to mark all the spans annotated with <mark  split='false' entity0='his wife; 2; Michelle_Obama' chain-before0='(2' chain-after0='2)'><annotator index='1' entity='Michelle_Obama' eval='correct' chain-before='(2' chain-after='2)'/>
<annotator index='2' entity='Michelle_Obama' eval='correct' chain-before='(2' chain-after='2)'/>
her</mark>
. You can see in green the &quot;chain&quot; where the underlined span belongs to, and in red the chain to which it was wrongly attributed. Click on the underlined span or a span without a mention to go back to the normal mode.
<metrics>
<annotator id='0'>
    <metric name='bcub' recall='0.6666667' precision='0.6666667'/>
    <metric name='ceafm' recall='0.6666667' precision='0.6666667'/>
    <metric name='muc' recall='0.75' precision='0.75'/>
    <metric name='ceafe' recall='0.6666667' precision='0.6666667'/>
</annotator>
<annotator id='1'>
    <metric name='bcub' recall='1.0' precision='1.0'/>
    <metric name='ceafm' recall='1.0' precision='1.0'/>
    <metric name='muc' recall='1.0' precision='1.0'/>
    <metric name='ceafe' recall='1.0' precision='1.0'/>
</annotator>
</metrics>
  </article>
  <article id='Options'>
JESICAT can combine either by same colors or same entities. Take for example &quot;<mark  split='false' entity0='bow; 1; bow_and_arrow' chain-before0='(1' chain-after0='1)'><annotator index='1' entity='violin_bow' eval='wrong' chain-before='(2' chain-after='2)'/>
<annotator index='2' entity='bow_and_stern_of_a_ship' eval='wrong' chain-before='(2' chain-after='2)'/>
bow</mark>
&quot;, a homonym with several meanings. All annotators got it wrong what the original author meant with this word, because of the lacking context. Jesicat assumes that the user wants to see when one annotator got it wrong but the other got it right, and so spans where all annotators got it wrong get combined by default. By choosing &quot;Combine same entities&quot; Jesicat would show the aforementioned &quot;bow&quot; in the split view, too.  Click on &quot;Show symbols&quot; to display a ✔, ✘ or ? symbol at the end of the spans for correct, wrong or missing. When you want to information about overlapping mentions, activate the &quot;Show entity numbers&quot; option. Mentions with the same entities get the same number, where &quot;(&quot; indicates the start and &quot;)&quot; indicates the end. The upper number of a span indicates the gold standard entity and the number at the bottom the one of the annotator.
<metrics>
<annotator id='0'>
    <metric name='bcub' recall='0.6666667' precision='0.6666667'/>
    <metric name='ceafm' recall='0.6666667' precision='0.6666667'/>
    <metric name='muc' recall='0.75' precision='0.75'/>
    <metric name='ceafe' recall='0.6666667' precision='0.6666667'/>
</annotator>
<annotator id='1'>
    <metric name='bcub' recall='1.0' precision='1.0'/>
    <metric name='ceafm' recall='1.0' precision='1.0'/>
    <metric name='muc' recall='1.0' precision='1.0'/>
    <metric name='ceafe' recall='1.0' precision='1.0'/>
</annotator>
<annotator id='2'>
    <metric name='bcub' recall='1.0' precision='1.0'/>
    <metric name='ceafm' recall='1.0' precision='1.0'/>
    <metric name='muc' recall='0.0' precision='0.0'/>
    <metric name='ceafe' recall='1.0' precision='1.0'/>
</annotator>
<annotator id='3'>
    <metric name='bcub' recall='1.0' precision='1.0'/>
    <metric name='ceafm' recall='1.0' precision='1.0'/>
    <metric name='muc' recall='0.0' precision='0.0'/>
    <metric name='ceafe' recall='1.0' precision='1.0'/>
</annotator>
</metrics>
  </article>
  <article id='Annotators'>
Click on &quot;Anno 2&quot; to hide the second annotator. You can still click on mentions to highlight the corresponding chains. Jesicat recalculates which mentions to show in the split/compact view.
<metrics>
<annotator id='0'>
    <metric name='bcub' recall='0.6666667' precision='0.6666667'/>
    <metric name='ceafm' recall='0.6666667' precision='0.6666667'/>
    <metric name='muc' recall='0.75' precision='0.75'/>
    <metric name='ceafe' recall='0.6666667' precision='0.6666667'/>
</annotator>
<annotator id='1'>
    <metric name='bcub' recall='1.0' precision='1.0'/>
    <metric name='ceafm' recall='1.0' precision='1.0'/>
    <metric name='muc' recall='1.0' precision='1.0'/>
    <metric name='ceafe' recall='1.0' precision='1.0'/>
</annotator>
<annotator id='2'>
    <metric name='bcub' recall='1.0' precision='1.0'/>
    <metric name='ceafm' recall='1.0' precision='1.0'/>
    <metric name='muc' recall='0.0' precision='0.0'/>
    <metric name='ceafe' recall='1.0' precision='1.0'/>
</annotator>
<annotator id='3'>
    <metric name='bcub' recall='1.0' precision='1.0'/>
    <metric name='ceafm' recall='1.0' precision='1.0'/>
    <metric name='muc' recall='0.0' precision='0.0'/>
    <metric name='ceafe' recall='1.0' precision='1.0'/>
</annotator>
<annotator id='4'>
    <metric name='bcub' recall='0.0' precision='0.0'/>
    <metric name='ceafm' recall='0.0' precision='0.0'/>
    <metric name='muc' recall='0.0' precision='0.0'/>
    <metric name='ceafe' recall='0.0' precision='0.0'/>
</annotator>
<annotator id='5'>
    <metric name='bcub' recall='0.0' precision='0.0'/>
    <metric name='ceafm' recall='0.0' precision='0.0'/>
    <metric name='muc' recall='0.0' precision='0.0'/>
    <metric name='ceafe' recall='0.0' precision='0.0'/>
</annotator>
</metrics>
  </article>
  <article id='Evaluation'>
On the right side you can see the evaluation. Choose your metric from the drop-down list. JESICAT will highlight the best annotator for recall and precision respectively.
<metrics>
<annotator id='0'>
    <metric name='bcub' recall='0.6666667' precision='0.6666667'/>
    <metric name='ceafm' recall='0.6666667' precision='0.6666667'/>
    <metric name='muc' recall='0.75' precision='0.75'/>
    <metric name='ceafe' recall='0.6666667' precision='0.6666667'/>
</annotator>
<annotator id='1'>
    <metric name='bcub' recall='1.0' precision='1.0'/>
    <metric name='ceafm' recall='1.0' precision='1.0'/>
    <metric name='muc' recall='1.0' precision='1.0'/>
    <metric name='ceafe' recall='1.0' precision='1.0'/>
</annotator>
<annotator id='2'>
    <metric name='bcub' recall='1.0' precision='1.0'/>
    <metric name='ceafm' recall='1.0' precision='1.0'/>
    <metric name='muc' recall='0.0' precision='0.0'/>
    <metric name='ceafe' recall='1.0' precision='1.0'/>
</annotator>
<annotator id='3'>
    <metric name='bcub' recall='1.0' precision='1.0'/>
    <metric name='ceafm' recall='1.0' precision='1.0'/>
    <metric name='muc' recall='0.0' precision='0.0'/>
    <metric name='ceafe' recall='1.0' precision='1.0'/>
</annotator>
<annotator id='4'>
    <metric name='bcub' recall='0.0' precision='0.0'/>
    <metric name='ceafm' recall='0.0' precision='0.0'/>
    <metric name='muc' recall='0.0' precision='0.0'/>
    <metric name='ceafe' recall='0.0' precision='0.0'/>
</annotator>
<annotator id='5'>
    <metric name='bcub' recall='0.0' precision='0.0'/>
    <metric name='ceafm' recall='0.0' precision='0.0'/>
    <metric name='muc' recall='0.0' precision='0.0'/>
    <metric name='ceafe' recall='0.0' precision='0.0'/>
</annotator>
<annotator id='6'>
    <metric name='bcub' recall='0.0' precision='0.0'/>
    <metric name='ceafm' recall='0.0' precision='0.0'/>
    <metric name='muc' recall='0.0' precision='0.0'/>
    <metric name='ceafe' recall='0.0' precision='0.0'/>
</annotator>
<annotator id='7'>
    <metric name='bcub' recall='0.0' precision='0.0'/>
    <metric name='ceafm' recall='0.0' precision='0.0'/>
    <metric name='muc' recall='0.0' precision='0.0'/>
    <metric name='ceafe' recall='0.0' precision='0.0'/>
</annotator>
</metrics>
  </article>

</articles>
